\doxysection{cereal\+::Load\+And\+Construct\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Struct Template Reference}
\hypertarget{structcereal_1_1_load_and_construct}{}\label{structcereal_1_1_load_and_construct}\index{cereal::LoadAndConstruct$<$ T $>$@{cereal::LoadAndConstruct$<$ T $>$}}


A class that allows cereal to load smart pointers to types that have no default constructor.  




{\ttfamily \#include $<$access.\+hpp$>$}



\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T$>$\newline
struct cereal\+::\+Load\+And\+Construct$<$ T $>$}
A class that allows cereal to load smart pointers to types that have no default constructor. 

If your class does not have a default constructor, cereal will not be able to load any smart pointers to it unless you overload \doxylink{structcereal_1_1_load_and_construct}{Load\+And\+Construct} for your class, and provide an appropriate load\+\_\+and\+\_\+construct method. You can also choose to define a member static function instead of specializing this class.

The specialization of \doxylink{structcereal_1_1_load_and_construct}{Load\+And\+Construct} must be placed within the cereal namespace\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyType}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ MyType(\ \textcolor{keywordtype}{int}\ x\ );\ \textcolor{comment}{//\ note:\ no\ default\ ctor}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ myX;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ Define\ a\ serialize\ or\ load/save\ pair\ as\ you\ normally\ would}}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ Archive>}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespacecereal_a02f9cfc9a4055c8a49eb050b02cd3357}{serialize}}(\ Archive\ \&\ ar\ )}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ ar(\ myX\ );}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Provide\ a\ specialization\ for\ LoadAndConstruct\ for\ your\ type}}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }cereal}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <>\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structcereal_1_1_load_and_construct}{LoadAndConstruct}}<MyType>}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ load\_and\_construct\ will\ be\ passed\ the\ archive\ that\ you\ will\ be\ loading}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ from\ as\ well\ as\ a\ construct\ object\ which\ you\ can\ use\ as\ if\ it\ were\ the}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ constructor\ for\ your\ type.\ \ cereal\ will\ handle\ all\ memory\ management\ for\ you.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ Archive>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ load\_and\_construct(\ Archive\ \&\ ar,\ cereal::construct<MyType>\ \&\ construct\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordtype}{int}\ x;}
\DoxyCodeLine{\ \ \ \ \ \ ar(\ x\ );}
\DoxyCodeLine{\ \ \ \ \ \ construct(\ x\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ if\ you\ require\ versioning,\ simply\ add\ a\ const\ std::uint32\_t\ as\ the\ final\ parameter,\ e.g.:}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ load\_and\_construct(\ Archive\ \&\ ar,\ cereal::construct<MyType>\ \&\ construct,\ std::uint32\_t\ const\ version\ )}}
\DoxyCodeLine{\ \ \};}
\DoxyCodeLine{\}\ \textcolor{comment}{//\ end\ namespace\ cereal}}

\end{DoxyCode}


Please note that just as in using external serialization functions, you cannot get access to non-\/public members of your class by befriending \doxylink{classcereal_1_1access}{cereal\+::access}. If you have the ability to modify the class you wish to serialize, it is recommended that you use member serialize functions and a static member load\+\_\+and\+\_\+construct function.

load\+\_\+and\+\_\+construct functions, regardless of whether they are static members of your class or whether you create one in the \doxylink{structcereal_1_1_load_and_construct}{Load\+And\+Construct} specialization, have the following signature\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ generally\ Archive\ will\ be\ templated,\ but\ it\ can\ be\ specific\ if\ desired}}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ Archive>}
\DoxyCodeLine{\textcolor{keyword}{static}\ \textcolor{keywordtype}{void}\ load\_and\_construct(\ Archive\ \&\ ar,\ cereal::construct<MyType>\ \&\ construct\ );}
\DoxyCodeLine{\textcolor{comment}{//\ with\ an\ optional\ last\ parameter\ specifying\ the\ version:\ const\ std::uint32\_t\ version}}

\end{DoxyCode}


Versioning behaves the same way as it does for standard serialization functions.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type to specialize for \\
\hline
\end{DoxyTemplParams}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
lib/cereal/\mbox{\hyperlink{access_8hpp}{access.\+hpp}}\end{DoxyCompactItemize}
