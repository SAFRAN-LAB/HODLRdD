<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HODLRdD: cereal Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HODLRdD<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Hierarchically off-diagonal low-rank matrix in d dimensions (HODLR d D), a black-box fast algorithm for particle simulations in d dimensions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('da/da6/namespacecereal.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">cereal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:access" id="r_access"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d71/classcereal_1_1access.html">access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be made a friend to give cereal access to non public functions.  <a href="../../d0/d71/classcereal_1_1access.html#details">More...</a><br /></td></tr>
<tr class="memitem:base_5Fclass" id="r_base_5Fclass"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d11/structcereal_1_1base__class.html">base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its non-virtual base class in a way that safely supports abstract classes.  <a href="../../df/d11/structcereal_1_1base__class.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryData" id="r_BinaryData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that can be serialized in a binary fashion.  <a href="../../d9/d73/structcereal_1_1_binary_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryInputArchive" id="r_BinaryInputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d9e/classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html" title="An output archive designed to save data in a compact binary representation.">BinaryOutputArchive</a>.  <a href="../../d9/d9e/classcereal_1_1_binary_input_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryOutputArchive" id="r_BinaryOutputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation.  <a href="../../dd/d4d/classcereal_1_1_binary_output_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:construct" id="r_construct"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dce/classcereal_1_1construct.html">construct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct types with no default constructor.  <a href="../../df/dce/classcereal_1_1construct.html#details">More...</a><br /></td></tr>
<tr class="memitem:DeferredData" id="r_DeferredData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that should be serialized after all non-deferred data.  <a href="../../d0/de7/classcereal_1_1_deferred_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:Exception" id="r_Exception"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df3/structcereal_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class thrown when things go wrong at runtime.  <a href="../../d0/df3/structcereal_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:InputArchive" id="r_InputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d72/classcereal_1_1_input_archive.html">InputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base input archive class.  <a href="../../d5/d72/classcereal_1_1_input_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:JSONInputArchive" id="r_JSONInputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data from JSON.  <a href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:JSONOutputArchive" id="r_JSONOutputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to JSON.  <a href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:LoadAndConstruct" id="r_LoadAndConstruct"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dac/structcereal_1_1_load_and_construct.html">LoadAndConstruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows cereal to load smart pointers to types that have no default constructor.  <a href="../../da/dac/structcereal_1_1_load_and_construct.html#details">More...</a><br /></td></tr>
<tr class="memitem:MapItem" id="r_MapItem"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ded/structcereal_1_1_map_item.html">MapItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a key and value for serializing data into maps.  <a href="../../d4/ded/structcereal_1_1_map_item.html#details">More...</a><br /></td></tr>
<tr class="memitem:NameValuePair" id="r_NameValuePair"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For holding name value pairs.  <a href="../../d5/d90/classcereal_1_1_name_value_pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:OutputArchive" id="r_OutputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcereal_1_1_output_archive.html">OutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base output archive class.  <a href="../../dc/d82/classcereal_1_1_output_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortableBinaryInputArchive" id="r_PortableBinaryInputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5c/classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="../../d6/d80/classcereal_1_1_portable_binary_output_archive.html" title="An output archive designed to save data in a compact binary representation portable over different ar...">PortableBinaryOutputArchive</a>.  <a href="../../da/d5c/classcereal_1_1_portable_binary_input_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortableBinaryOutputArchive" id="r_PortableBinaryOutputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d80/classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation portable over different architectures.  <a href="../../d6/d80/classcereal_1_1_portable_binary_output_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:RapidJSONException" id="r_RapidJSONException"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dcf/structcereal_1_1_rapid_j_s_o_n_exception.html">RapidJSONException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when rapidjson fails an internal assertion.  <a href="../../d7/dcf/structcereal_1_1_rapid_j_s_o_n_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:SizeTag" id="r_SizeTag"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around size metadata.  <a href="../../d6/ddf/classcereal_1_1_size_tag.html#details">More...</a><br /></td></tr>
<tr class="memitem:specialize" id="r_specialize"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d96/structcereal_1_1specialize.html">specialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.  <a href="../../d7/d96/structcereal_1_1specialize.html#details">More...</a><br /></td></tr>
<tr class="memitem:virtual_5Fbase_5Fclass" id="r_virtual_5Fbase_5Fclass"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d81/structcereal_1_1virtual__base__class.html">virtual_base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its virtual base class in a way that allows cereal to track inheritance.  <a href="../../d3/d81/structcereal_1_1virtual__base__class.html#details">More...</a><br /></td></tr>
<tr class="memitem:XMLInputArchive" id="r_XMLInputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to load data from XML.  <a href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html#details">More...</a><br /></td></tr>
<tr class="memitem:XMLOutputArchive" id="r_XMLOutputArchive"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to XML.  <a href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0e01d80aaafe0efb12b75abdee310ae4" id="r_a0e01d80aaafe0efb12b75abdee310ae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e01d80aaafe0efb12b75abdee310ae4">size_type</a> = <a class="el" href="../../db/dbe/macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td></tr>
<tr class="memdesc:a0e01d80aaafe0efb12b75abdee310ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type used by cereal.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a95185aa9f39e4ac382bb6631beb68a67" id="r_a95185aa9f39e4ac382bb6631beb68a67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95185aa9f39e4ac382bb6631beb68a67">Flags</a> { <b>AllowEmptyClassElision</b> = 1
 }</td></tr>
<tr class="memdesc:a95185aa9f39e4ac382bb6631beb68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special flags for archives.  <a href="#a95185aa9f39e4ac382bb6631beb68a67">More...</a><br /></td></tr>
<tr class="memitem:ac28bb730353e53b3066cc679e63bb108" id="r_ac28bb730353e53b3066cc679e63bb108"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d96/structcereal_1_1specialize.html#ac28bb730353e53b3066cc679e63bb108">specialization</a> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2287a243ece679a7cfad54641c790ecc" id="r_a2287a243ece679a7cfad54641c790ecc"><td class="memTemplParams" colspan="2"><a id="a2287a243ece679a7cfad54641c790ecc" name="a2287a243ece679a7cfad54641c790ecc"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a2287a243ece679a7cfad54641c790ecc template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a2287a243ece679a7cfad54641c790ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to binary. <br /></td></tr>
<tr class="memitem:a960b7971cfb99b3c826258369bfc01e9" id="r_a960b7971cfb99b3c826258369bfc01e9"><td class="memTemplParams" colspan="2"><a id="a960b7971cfb99b3c826258369bfc01e9" name="a960b7971cfb99b3c826258369bfc01e9"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a960b7971cfb99b3c826258369bfc01e9 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d9/d9e/classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a960b7971cfb99b3c826258369bfc01e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from binary. <br /></td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3" id="r_a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to binary.  <br /></td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a" id="r_ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5fb9b1468920e7e23cb2817e65fed4a">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing SizeTags to binary.  <br /></td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5" id="r_a189662781a0f3b710901f892d87792d5"><td class="memTemplParams" colspan="2"><a id="a189662781a0f3b710901f892d87792d5" name="a189662781a0f3b710901f892d87792d5"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;ar, <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a189662781a0f3b710901f892d87792d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data. <br /></td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac" id="r_af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplParams" colspan="2"><a id="af8577c2834d64922e9460cad77f9a3ac" name="af8577c2834d64922e9460cad77f9a3ac"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d9/d9e/classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;ar, <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:af8577c2834d64922e9460cad77f9a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data. <br /></td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40" id="r_ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac267b8915a13f4433fc25aa9d310ee40">prologue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac267b8915a13f4433fc25aa9d310ee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <br /></td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa" id="r_ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplParams" colspan="2"><a id="ae77f745fd34dd83fa6543e0fa478bdfa" name="ae77f745fd34dd83fa6543e0fa478bdfa"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives. <br /></td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade" id="r_a3bec173adc6146ecc712921c2d257ade"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bec173adc6146ecc712921c2d257ade">epilogue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a3bec173adc6146ecc712921c2d257ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <br /></td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22" id="r_a99326c431920835d61e5bfc51b865f22"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99326c431920835d61e5bfc51b865f22">epilogue</a> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a99326c431920835d61e5bfc51b865f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <br /></td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7" id="r_ab4eb0997ec3815e2be77c35351d02cf7"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4eb0997ec3815e2be77c35351d02cf7">prologue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ab4eb0997ec3815e2be77c35351d02cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives.  <br /></td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7" id="r_a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memTemplParams" colspan="2"><a id="a6ff01a6c38b02073beb88b56f80b0ba7" name="a6ff01a6c38b02073beb88b56f80b0ba7"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives. <br /></td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6" id="r_ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c0c3b1ea7aadc84af34b815bfad6a6">epilogue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <br /></td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9" id="r_a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ae425e0a66c44b7d39b16d0a6a7f0d9">epilogue</a> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <br /></td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb" id="r_a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f7ec98da774f9e0af596620859d8ccb">prologue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5f7ec98da774f9e0af596620859d8ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c" id="r_accec39647fd17ad5470e42a5c371701c"><td class="memTemplParams" colspan="2"><a id="accec39647fd17ad5470e42a5c371701c" name="accec39647fd17ad5470e42a5c371701c"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:accec39647fd17ad5470e42a5c371701c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives. <br /></td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567" id="r_ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab92526cf5d3f4a642d918a027d2e4567">epilogue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ab92526cf5d3f4a642d918a027d2e4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270" id="r_acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplParams" colspan="2"><a id="acb582097a98c0558c1a6b3cf0ef52270" name="acb582097a98c0558c1a6b3cf0ef52270"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:acb582097a98c0558c1a6b3cf0ef52270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives. <br /></td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39" id="r_aba2924cd871a88c20023171f74a68d39"><td class="memTemplParams" colspan="2">template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value, !<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2924cd871a88c20023171f74a68d39">prologue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:aba2924cd871a88c20023171f74a68d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives (except minimal types)  <br /></td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07" id="r_af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplParams" colspan="2"><a id="af88fce78fe97297ab4d22a607fee1e07" name="af88fce78fe97297ab4d22a607fee1e07"></a>
template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;::value, !<a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af88fce78fe97297ab4d22a607fee1e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives. <br /></td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b" id="r_abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplParams" colspan="2">template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value, !<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb6adc568591c0a525f2c16ea5912c5b">epilogue</a> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:abb6adc568591c0a525f2c16ea5912c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives (except minimal types)  <br /></td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554" id="r_a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplParams" colspan="2"><a id="a5cdc10b14dce9340a8df6cb18ac74554" name="a5cdc10b14dce9340a8df6cb18ac74554"></a>
template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;::value, !<a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a5cdc10b14dce9340a8df6cb18ac74554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives. <br /></td></tr>
<tr class="memitem:a956c4c0578baf265811497c965c4a382" id="r_a956c4c0578baf265811497c965c4a382"><td class="memItemLeft" align="right" valign="top"><a id="a956c4c0578baf265811497c965c4a382" name="a956c4c0578baf265811497c965c4a382"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a956c4c0578baf265811497c965c4a382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:aef075a9d94a926df8ba17689914233e2" id="r_aef075a9d94a926df8ba17689914233e2"><td class="memItemLeft" align="right" valign="top"><a id="aef075a9d94a926df8ba17689914233e2" name="aef075a9d94a926df8ba17689914233e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:aef075a9d94a926df8ba17689914233e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:ad67f92a71f4318dd69e6dec516fe57dd" id="r_ad67f92a71f4318dd69e6dec516fe57dd"><td class="memItemLeft" align="right" valign="top"><a id="ad67f92a71f4318dd69e6dec516fe57dd" name="ad67f92a71f4318dd69e6dec516fe57dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:ad67f92a71f4318dd69e6dec516fe57dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:a9198bda1f28453a9ead2f8999e5fb449" id="r_a9198bda1f28453a9ead2f8999e5fb449"><td class="memItemLeft" align="right" valign="top"><a id="a9198bda1f28453a9ead2f8999e5fb449" name="a9198bda1f28453a9ead2f8999e5fb449"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a9198bda1f28453a9ead2f8999e5fb449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39" id="r_aba2924cd871a88c20023171f74a68d39"><td class="memTemplParams" colspan="2"><a id="aba2924cd871a88c20023171f74a68d39" name="aba2924cd871a88c20023171f74a68d39"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:aba2924cd871a88c20023171f74a68d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:a228d2e3eb9715612cde28f829b73deea" id="r_a228d2e3eb9715612cde28f829b73deea"><td class="memTemplParams" colspan="2"><a id="a228d2e3eb9715612cde28f829b73deea" name="a228d2e3eb9715612cde28f829b73deea"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a228d2e3eb9715612cde28f829b73deea template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, T const &amp;)</td></tr>
<tr class="memdesc:a228d2e3eb9715612cde28f829b73deea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:ab7ce2a191261216f3865499d0cdf2ccf" id="r_ab7ce2a191261216f3865499d0cdf2ccf"><td class="memTemplParams" colspan="2"><a id="ab7ce2a191261216f3865499d0cdf2ccf" name="ab7ce2a191261216f3865499d0cdf2ccf"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:ab7ce2a191261216f3865499d0cdf2ccf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, T const &amp;)</td></tr>
<tr class="memdesc:ab7ce2a191261216f3865499d0cdf2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:ac62f3282759af4c0f118b4caaa0b6eec" id="r_ac62f3282759af4c0f118b4caaa0b6eec"><td class="memTemplParams" colspan="2"><a id="ac62f3282759af4c0f118b4caaa0b6eec" name="ac62f3282759af4c0f118b4caaa0b6eec"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:ac62f3282759af4c0f118b4caaa0b6eec template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, T const &amp;)</td></tr>
<tr class="memdesc:ac62f3282759af4c0f118b4caaa0b6eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives. <br /></td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78" id="r_adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplParams" colspan="2"><a id="adacd1c15f7ed1793453e56a675bd0a78" name="adacd1c15f7ed1793453e56a675bd0a78"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:adacd1c15f7ed1793453e56a675bd0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives. <br /></td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841" id="r_a4dde17944a1c24885e39ff673b402841"><td class="memTemplParams" colspan="2"><a id="a4dde17944a1c24885e39ff673b402841" name="a4dde17944a1c24885e39ff673b402841"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a4dde17944a1c24885e39ff673b402841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives. <br /></td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94" id="r_aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplParams" colspan="2"><a id="aa06f0f66ced9dd9c85377ba61054df94" name="aa06f0f66ced9dd9c85377ba61054df94"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:aa06f0f66ced9dd9c85377ba61054df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives. <br /></td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253" id="r_a733225f7be628b7c4dfca463d6a44253"><td class="memTemplParams" colspan="2"><a id="a733225f7be628b7c4dfca463d6a44253" name="a733225f7be628b7c4dfca463d6a44253"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a733225f7be628b7c4dfca463d6a44253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives. <br /></td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb" id="r_a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplParams" colspan="2"><a id="a049f4acf75e647cce18b4b98c9037cfb" name="a049f4acf75e647cce18b4b98c9037cfb"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a049f4acf75e647cce18b4b98c9037cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to JSON. <br /></td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2" id="r_a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplParams" colspan="2"><a id="a42319b92c41f6f15a86b69fcd87246d2" name="a42319b92c41f6f15a86b69fcd87246d2"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memitem:ad05ab834a18302c852181802b22d30ec" id="r_ad05ab834a18302c852181802b22d30ec"><td class="memItemLeft" align="right" valign="top"><a id="ad05ab834a18302c852181802b22d30ec" name="ad05ab834a18302c852181802b22d30ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;t)</td></tr>
<tr class="memdesc:ad05ab834a18302c852181802b22d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for nullptr to JSON. <br /></td></tr>
<tr class="memitem:aed7f1f974a532bbad87a7b4d8fe746e8" id="r_aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memItemLeft" align="right" valign="top"><a id="aed7f1f974a532bbad87a7b4d8fe746e8" name="aed7f1f974a532bbad87a7b4d8fe746e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, std::nullptr_t &amp;t)</td></tr>
<tr class="memdesc:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON. <br /></td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909" id="r_a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplParams" colspan="2"><a id="a272e0c7b90d4591e8e0a13ebb17ca909" name="a272e0c7b90d4591e8e0a13ebb17ca909"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for arithmetic to JSON. <br /></td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961" id="r_af0f34376d3320a6fd7be58df311bd961"><td class="memTemplParams" colspan="2"><a id="af0f34376d3320a6fd7be58df311bd961" name="af0f34376d3320a6fd7be58df311bd961"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:af0f34376d3320a6fd7be58df311bd961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON. <br /></td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff" id="r_a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplParams" colspan="2"><a id="a94cbcd5c53fd79f0f97b816820b013ff" name="a94cbcd5c53fd79f0f97b816820b013ff"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a94cbcd5c53fd79f0f97b816820b013ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to JSON <br /></td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30" id="r_a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplParams" colspan="2"><a id="a8a9afcaeb51833d26e15a78d55e5ae30" name="a8a9afcaeb51833d26e15a78d55e5ae30"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from JSON <br /></td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde" id="r_a66b30facce64dd6f270097f144f9ffde"><td class="memTemplParams" colspan="2"><a id="a66b30facce64dd6f270097f144f9ffde" name="a66b30facce64dd6f270097f144f9ffde"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a66b30facce64dd6f270097f144f9ffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to JSON. <br /></td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057" id="r_ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplParams" colspan="2"><a id="ab8e7a02ebbdcca274a8c905878725057" name="ab8e7a02ebbdcca274a8c905878725057"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:ab8e7a02ebbdcca274a8c905878725057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from JSON. <br /></td></tr>
<tr class="memitem:aa2a82fca196f0aaac88c78a46ab52475" id="r_aa2a82fca196f0aaac88c78a46ab52475"><td class="memTemplParams" colspan="2"><a id="aa2a82fca196f0aaac88c78a46ab52475" name="aa2a82fca196f0aaac88c78a46ab52475"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:aa2a82fca196f0aaac88c78a46ab52475 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d6/d80/classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:aa2a82fca196f0aaac88c78a46ab52475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to portable binary. <br /></td></tr>
<tr class="memitem:a8969743ff3cd671810d314350f4d4a8a" id="r_a8969743ff3cd671810d314350f4d4a8a"><td class="memTemplParams" colspan="2"><a id="a8969743ff3cd671810d314350f4d4a8a" name="a8969743ff3cd671810d314350f4d4a8a"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a8969743ff3cd671810d314350f4d4a8a template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../da/d5c/classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a8969743ff3cd671810d314350f4d4a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from portable binary. <br /></td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7" id="r_a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplParams" colspan="2"><a id="a4ba55a1d28e2db9a09ba767a4b1f16d7" name="a4ba55a1d28e2db9a09ba767a4b1f16d7"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d6/d80/classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;ar, <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data to portable binary. <br /></td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec" id="r_a10780060393e472b72fb4a2158d641ec"><td class="memTemplParams" colspan="2"><a id="a10780060393e472b72fb4a2158d641ec" name="a10780060393e472b72fb4a2158d641ec"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../da/d5c/classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;ar, <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:a10780060393e472b72fb4a2158d641ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data from portable binary. <br /></td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7" id="r_a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2582cc8477f9482910fc5733e13f75f7">prologue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a2582cc8477f9482910fc5733e13f75f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML output archives.  <br /></td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2" id="r_a06224101dfaf6979418326a7664e13e2"><td class="memTemplParams" colspan="2"><a id="a06224101dfaf6979418326a7664e13e2" name="a06224101dfaf6979418326a7664e13e2"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a06224101dfaf6979418326a7664e13e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML input archives. <br /></td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d" id="r_a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a906ef65c3ab455598f768431bcd5f37d">epilogue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a906ef65c3ab455598f768431bcd5f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML output archives.  <br /></td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80" id="r_a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplParams" colspan="2"><a id="a5d1af5fa5a466ad0cd89513aab823b80" name="a5d1af5fa5a466ad0cd89513aab823b80"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5d1af5fa5a466ad0cd89513aab823b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML input archives. <br /></td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3" id="r_a6124c7acd34d3740cbedd39559da73c3"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6124c7acd34d3740cbedd39559da73c3">prologue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a6124c7acd34d3740cbedd39559da73c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives.  <br /></td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951" id="r_adf285317856bf80daaa225e171d8d951"><td class="memTemplParams" colspan="2"><a id="adf285317856bf80daaa225e171d8d951" name="adf285317856bf80daaa225e171d8d951"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:adf285317856bf80daaa225e171d8d951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives. <br /></td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0" id="r_acb1f17a3cae999a9be34889fd2c509a0"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb1f17a3cae999a9be34889fd2c509a0">epilogue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:acb1f17a3cae999a9be34889fd2c509a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <br /></td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64" id="r_a70bbce1604367ea45c07dc677186ed64"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70bbce1604367ea45c07dc677186ed64">epilogue</a> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a70bbce1604367ea45c07dc677186ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <br /></td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0" id="r_adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb541e9594201d78a04cb11ad806ba0">prologue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:adbb541e9594201d78a04cb11ad806ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for XML output archives.  <br /></td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76" id="r_aa25e6485f450649b931e07e0f6384a76"><td class="memTemplParams" colspan="2"><a id="aa25e6485f450649b931e07e0f6384a76" name="aa25e6485f450649b931e07e0f6384a76"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53" id="r_ac3700f36066026da589faa60fed7ca53"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3700f36066026da589faa60fed7ca53">epilogue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac3700f36066026da589faa60fed7ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for XML output archives.  <br /></td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208" id="r_ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplParams" colspan="2"><a id="ada513bbfcf8c1996e6f7a439f129a208" name="ada513bbfcf8c1996e6f7a439f129a208"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1" id="r_af751c02a4443b571fee21416a4b899c1"><td class="memTemplParams" colspan="2">template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value||<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af751c02a4443b571fee21416a4b899c1">prologue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af751c02a4443b571fee21416a4b899c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML output archives (except minimal types)  <br /></td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0" id="r_a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplParams" colspan="2"><a id="a7ea2b824c9d003b9e2b36473db1d22c0" name="a7ea2b824c9d003b9e2b36473db1d22c0"></a>
template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;::value||<a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>prologue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML input archives (except minimal types) <br /></td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414" id="r_a16ca55f7d5556527de1584198ea3c414"><td class="memTemplParams" colspan="2">template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value||<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ca55f7d5556527de1584198ea3c414">epilogue</a> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a16ca55f7d5556527de1584198ea3c414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <br /></td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd" id="r_ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplParams" colspan="2"><a id="ae06e3f89a66231db109db984a87e0cfd" name="ae06e3f89a66231db109db984a87e0cfd"></a>
template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;::value||<a class="el" href="../../da/de8/structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>epilogue</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:ae06e3f89a66231db109db984a87e0cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types) <br /></td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b" id="r_a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplParams" colspan="2"><a id="a9a252f7731760e1186c3c552f640fc7b" name="a9a252f7731760e1186c3c552f640fc7b"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a9a252f7731760e1186c3c552f640fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving NVP types to XML. <br /></td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380" id="r_a0a08767af52642e109545f05a4694380"><td class="memTemplParams" colspan="2"><a id="a0a08767af52642e109545f05a4694380" name="a0a08767af52642e109545f05a4694380"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a0a08767af52642e109545f05a4694380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading NVP types from XML. <br /></td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2" id="r_a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplParams" colspan="2"><a id="a1703ea149fc65a4d7851fa85823287b2" name="a1703ea149fc65a4d7851fa85823287b2"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a1703ea149fc65a4d7851fa85823287b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to XML. <br /></td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf" id="r_a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplParams" colspan="2"><a id="a88090838a4dbf54f907dee8969c0d5cf" name="a88090838a4dbf54f907dee8969c0d5cf"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:a88090838a4dbf54f907dee8969c0d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from XML. <br /></td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31" id="r_ac6311a745c3a12848550eff8fba71f31"><td class="memTemplParams" colspan="2"><a id="ac6311a745c3a12848550eff8fba71f31" name="ac6311a745c3a12848550eff8fba71f31"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:ac6311a745c3a12848550eff8fba71f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to xml. <br /></td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468" id="r_aea476a67114d4998f2113da658c25468"><td class="memTemplParams" colspan="2"><a id="aea476a67114d4998f2113da658c25468" name="aea476a67114d4998f2113da658c25468"></a>
template&lt;class T, traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:aea476a67114d4998f2113da658c25468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from xml. <br /></td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8" id="r_a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplParams" colspan="2"><a id="a63696aa0de3dc95bc27f97bf455d15e8" name="a63696aa0de3dc95bc27f97bf455d15e8"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (<a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a63696aa0de3dc95bc27f97bf455d15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to xml <br /></td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37" id="r_a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplParams" colspan="2"><a id="a3f5b214a91e6d61bcdae422e1cf27b37" name="a3f5b214a91e6d61bcdae422e1cf27b37"></a>
template&lt;class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (<a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from xml <br /></td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453" id="r_a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8093b5f7cfd618fae6350ef7b2c09453">prologue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e" id="r_a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1153b7ce7ffbb86e2c81e076a252938e">epilogue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="memitem:a72323b9f6443491b5fe35133c22b7060" id="r_a72323b9f6443491b5fe35133c22b7060"><td class="memTemplParams" colspan="2"><a id="a72323b9f6443491b5fe35133c22b7060" name="a72323b9f6443491b5fe35133c22b7060"></a>
template&lt;class KeyType, class ValueType&gt; </td></tr>
<tr class="memitem:a72323b9f6443491b5fe35133c22b7060 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/ded/structcereal_1_1_map_item.html">MapItem</a>&lt; KeyType, ValueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_map_item</b> (KeyType &amp;&amp;key, ValueType &amp;&amp;value)</td></tr>
<tr class="memdesc:a72323b9f6443491b5fe35133c22b7060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../d4/ded/structcereal_1_1_map_item.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together. <br /></td></tr>
<tr class="memitem:a54c9c74df6d91319b01128690322690a" id="r_a54c9c74df6d91319b01128690322690a"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T, size_t N&gt; </td></tr>
<tr class="memitem:a54c9c74df6d91319b01128690322690a template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54c9c74df6d91319b01128690322690a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="memitem:a5c962df81c2ad99813597b6238e3e17d" id="r_a5c962df81c2ad99813597b6238e3e17d"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T, size_t N&gt; </td></tr>
<tr class="memitem:a5c962df81c2ad99813597b6238e3e17d template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c962df81c2ad99813597b6238e3e17d">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memitem:a668c4c41f5ca325091d5a357f89040c3" id="r_a668c4c41f5ca325091d5a357f89040c3"><td class="memTemplParams" colspan="2"><a id="a668c4c41f5ca325091d5a357f89040c3" name="a668c4c41f5ca325091d5a357f89040c3"></a>
template&lt;class Archive, class T, size_t N&gt; </td></tr>
<tr class="memitem:a668c4c41f5ca325091d5a357f89040c3 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="memdesc:a668c4c41f5ca325091d5a357f89040c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::array all other types. <br /></td></tr>
<tr class="memitem:ad1956f9852b727abcb5ee439dd8abf39" id="r_ad1956f9852b727abcb5ee439dd8abf39"><td class="memTemplParams" colspan="2"><a id="ad1956f9852b727abcb5ee439dd8abf39" name="ad1956f9852b727abcb5ee439dd8abf39"></a>
template&lt;class Archive, class T, size_t N&gt; </td></tr>
<tr class="memitem:ad1956f9852b727abcb5ee439dd8abf39 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memdesc:ad1956f9852b727abcb5ee439dd8abf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::array all other types. <br /></td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a" id="r_a99bab555e921d35f6f713b7e1cab187a"><td class="memTemplParams" colspan="2"><a id="a99bab555e921d35f6f713b7e1cab187a" name="a99bab555e921d35f6f713b7e1cab187a"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::atomic&lt; T &gt; const &amp;a)</td></tr>
<tr class="memdesc:a99bab555e921d35f6f713b7e1cab187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::atomic. <br /></td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de" id="r_abfc0336db29043e0f692517c77f9e7de"><td class="memTemplParams" colspan="2"><a id="abfc0336db29043e0f692517c77f9e7de" name="abfc0336db29043e0f692517c77f9e7de"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::atomic&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:abfc0336db29043e0f692517c77f9e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::atomic. <br /></td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126" id="r_a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplParams" colspan="2"><a id="a397c996c1b3e8bdcb3f43f11edf91126" name="a397c996c1b3e8bdcb3f43f11edf91126"></a>
template&lt;class Archive, size_t N, traits::EnableIf&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; std::uint32_t &gt;, Archive &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::bitset&lt; N &gt; const &amp;bits)</td></tr>
<tr class="memdesc:a397c996c1b3e8bdcb3f43f11edf91126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::bitset when <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported. <br /></td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126" id="r_a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplParams" colspan="2"><a id="a397c996c1b3e8bdcb3f43f11edf91126" name="a397c996c1b3e8bdcb3f43f11edf91126"></a>
template&lt;class Archive, size_t N, traits::DisableIf&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; std::uint32_t &gt;, Archive &gt;::value &gt; = traits::sfinae&gt; </td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::bitset&lt; N &gt; const &amp;bits)</td></tr>
<tr class="memdesc:a397c996c1b3e8bdcb3f43f11edf91126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::bitset when <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> is not supported. <br /></td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60" id="r_ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplParams" colspan="2"><a id="ad8cfa5e251b7a85343f0a92e93f50a60" name="ad8cfa5e251b7a85343f0a92e93f50a60"></a>
template&lt;class Archive, size_t N&gt; </td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::bitset&lt; N &gt; &amp;bits)</td></tr>
<tr class="memdesc:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::bitset. <br /></td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff" id="r_aaef0d6cf11362910537f60cf2d977bff"><td class="memTemplParams" colspan="2"><a id="aaef0d6cf11362910537f60cf2d977bff" name="aaef0d6cf11362910537f60cf2d977bff"></a>
template&lt;class Archive, typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; const &amp;variant)</td></tr>
<tr class="memdesc:aaef0d6cf11362910537f60cf2d977bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for boost::variant. <br /></td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772" id="r_a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memTemplParams" colspan="2"><a id="a890ad33a3d0ec4f9d7408e6e7e25e772" name="a890ad33a3d0ec4f9d7408e6e7e25e772"></a>
template&lt;class Archive, typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for boost::variant. <br /></td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349" id="r_a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplParams" colspan="2"><a id="a873e6efe3a391c89edbee86fb2a4b349" name="a873e6efe3a391c89edbee86fb2a4b349"></a>
template&lt;class Archive, class R, class P&gt; </td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a873e6efe3a391c89edbee86fb2a4b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::duration. <br /></td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30" id="r_a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplParams" colspan="2"><a id="a09c5a2d538bb7606e5500f5e3a107e30" name="a09c5a2d538bb7606e5500f5e3a107e30"></a>
template&lt;class Archive, class R, class P&gt; </td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; &amp;dur)</td></tr>
<tr class="memdesc:a09c5a2d538bb7606e5500f5e3a107e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::duration. <br /></td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6" id="r_a977c1527242726fecf6cb1f492683ca6"><td class="memTemplParams" colspan="2"><a id="a977c1527242726fecf6cb1f492683ca6" name="a977c1527242726fecf6cb1f492683ca6"></a>
template&lt;class Archive, class C, class D&gt; </td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a977c1527242726fecf6cb1f492683ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::time_point. <br /></td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649" id="r_ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplParams" colspan="2"><a id="ab8b65d3b13a15b4f35c1b21553ab7649" name="ab8b65d3b13a15b4f35c1b21553ab7649"></a>
template&lt;class Archive, class C, class D&gt; </td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; &amp;dur)</td></tr>
<tr class="memdesc:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::time_point. <br /></td></tr>
<tr class="memitem:aa282de424af3d15ebfd094a216029149" id="r_aa282de424af3d15ebfd094a216029149"><td class="memTemplParams" colspan="2"><a id="aa282de424af3d15ebfd094a216029149" name="aa282de424af3d15ebfd094a216029149"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:aa282de424af3d15ebfd094a216029149 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../db/de5/classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, typenamecommon_detail::is_enum&lt; T &gt;::base_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_MINIMAL_FUNCTION_NAME</b> (Archive const &amp;, T const &amp;t)</td></tr>
<tr class="memdesc:aa282de424af3d15ebfd094a216029149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for enum types. <br /></td></tr>
<tr class="memitem:a0a4c34802b85e6ef9331374de8be9d22" id="r_a0a4c34802b85e6ef9331374de8be9d22"><td class="memTemplParams" colspan="2"><a id="a0a4c34802b85e6ef9331374de8be9d22" name="a0a4c34802b85e6ef9331374de8be9d22"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a0a4c34802b85e6ef9331374de8be9d22 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../db/de5/classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_MINIMAL_FUNCTION_NAME</b> (Archive const &amp;, T &amp;&amp;t, typename <a class="el" href="../../db/de5/classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type const &amp;value)</td></tr>
<tr class="memdesc:a0a4c34802b85e6ef9331374de8be9d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for enum types. <br /></td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770" id="r_a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676a85ac8cfcd512a743f930a10b6770">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, T *&amp;)</td></tr>
<tr class="memdesc:a676a85ac8cfcd512a743f930a10b6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for raw pointers.  <br /></td></tr>
<tr class="memitem:a03728f69af179b3cb5e2ec9131b8ccc3" id="r_a03728f69af179b3cb5e2ec9131b8ccc3"><td class="memTemplParams" colspan="2"><a id="a03728f69af179b3cb5e2ec9131b8ccc3" name="a03728f69af179b3cb5e2ec9131b8ccc3"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a03728f69af179b3cb5e2ec9131b8ccc3 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SERIALIZE_FUNCTION_NAME</b> (Archive &amp;ar, T &amp;array)</td></tr>
<tr class="memdesc:a03728f69af179b3cb5e2ec9131b8ccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for C style arrays. <br /></td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5" id="r_a548257a795f8540c86333d0758fb99d5"><td class="memTemplParams" colspan="2"><a id="a548257a795f8540c86333d0758fb99d5" name="a548257a795f8540c86333d0758fb99d5"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::complex&lt; T &gt; const &amp;comp)</td></tr>
<tr class="memdesc:a548257a795f8540c86333d0758fb99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::complex. <br /></td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e" id="r_afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplParams" colspan="2"><a id="afdc7cefa0f45ae9d873598fdc607320e" name="afdc7cefa0f45ae9d873598fdc607320e"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::complex&lt; T &gt; &amp;bits)</td></tr>
<tr class="memdesc:afdc7cefa0f45ae9d873598fdc607320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::complex. <br /></td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1" id="r_a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplParams" colspan="2"><a id="a0c5992e59041b20f902dd4fa0b2c62f1" name="a0c5992e59041b20f902dd4fa0b2c62f1"></a>
template&lt;class Archive, template&lt; typename... &gt; class Map, typename... Args, typename = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, Map&lt; Args... &gt; const &amp;map)</td></tr>
<tr class="memdesc:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std-like pair associative containers. <br /></td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3" id="r_a679144f687ff95c7111ff96bccc573b3"><td class="memTemplParams" colspan="2"><a id="a679144f687ff95c7111ff96bccc573b3" name="a679144f687ff95c7111ff96bccc573b3"></a>
template&lt;class Archive, template&lt; typename... &gt; class Map, typename... Args, typename = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, Map&lt; Args... &gt; &amp;map)</td></tr>
<tr class="memdesc:a679144f687ff95c7111ff96bccc573b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std-like pair associative containers. <br /></td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad" id="r_a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplParams" colspan="2"><a id="a2e7e7370c46e4a819bd35fc1cdb856ad" name="a2e7e7370c46e4a819bd35fc1cdb856ad"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::deque&lt; T, A &gt; const &amp;deque)</td></tr>
<tr class="memdesc:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::deque. <br /></td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878" id="r_a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplParams" colspan="2"><a id="a284b8541ec2e00a17dada43f2d59d878" name="a284b8541ec2e00a17dada43f2d59d878"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::deque&lt; T, A &gt; &amp;deque)</td></tr>
<tr class="memdesc:a284b8541ec2e00a17dada43f2d59d878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::deque. <br /></td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6" id="r_a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplParams" colspan="2"><a id="a69af5df93ccfbbb3cc02575e3aeadbc6" name="a69af5df93ccfbbb3cc02575e3aeadbc6"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::forward_list&lt; T, A &gt; const &amp;forward_list)</td></tr>
<tr class="memdesc:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::forward_list all other types. <br /></td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579" id="r_a42e9e22a3423e77493cee1d858372579"><td class="memTemplParams" colspan="2"><a id="a42e9e22a3423e77493cee1d858372579" name="a42e9e22a3423e77493cee1d858372579"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::forward_list&lt; T, A &gt; &amp;forward_list)</td></tr>
<tr class="memdesc:a42e9e22a3423e77493cee1d858372579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::forward_list all other types from. <br /></td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357" id="r_a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplParams" colspan="2"><a id="a02f9cfc9a4055c8a49eb050b02cd3357" name="a02f9cfc9a4055c8a49eb050b02cd3357"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (Archive &amp;, std::less&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::less. <br /></td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba" id="r_ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplParams" colspan="2"><a id="ad5738ab4196d02509a5b69a58c7ca6ba" name="ad5738ab4196d02509a5b69a58c7ca6ba"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::list&lt; T, A &gt; const &amp;list)</td></tr>
<tr class="memdesc:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::list. <br /></td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59" id="r_a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplParams" colspan="2"><a id="a55808d42ce0c468d57c34bbc07827e59" name="a55808d42ce0c468d57c34bbc07827e59"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::list&lt; T, A &gt; &amp;list)</td></tr>
<tr class="memdesc:a55808d42ce0c468d57c34bbc07827e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::list. <br /></td></tr>
<tr class="memitem:a8f598f6d4fbee3b354eb83e597cb0ebe" id="r_a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="memTemplParams" colspan="2"><a id="a8f598f6d4fbee3b354eb83e597cb0ebe" name="a8f598f6d4fbee3b354eb83e597cb0ebe"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a8f598f6d4fbee3b354eb83e597cb0ebe template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for non polymorphic types. <br /></td></tr>
<tr class="memitem:ada32ad49436ba6eadf59fe88c9ffc6d8" id="r_ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="memTemplParams" colspan="2"><a id="ada32ad49436ba6eadf59fe88c9ffc6d8" name="ada32ad49436ba6eadf59fe88c9ffc6d8"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ada32ad49436ba6eadf59fe88c9ffc6d8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct for non polymorphic types. <br /></td></tr>
<tr class="memitem:a6ac5820fd45ce7b235c753be49a2913c" id="r_a6ac5820fd45ce7b235c753be49a2913c"><td class="memTemplParams" colspan="2"><a id="a6ac5820fd45ce7b235c753be49a2913c" name="a6ac5820fd45ce7b235c753be49a2913c"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a6ac5820fd45ce7b235c753be49a2913c template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a6ac5820fd45ce7b235c753be49a2913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for non polymorphic types. <br /></td></tr>
<tr class="memitem:ad4a9fc2e4a59628aca00743710cf238f" id="r_ad4a9fc2e4a59628aca00743710cf238f"><td class="memTemplParams" colspan="2"><a id="ad4a9fc2e4a59628aca00743710cf238f" name="ad4a9fc2e4a59628aca00743710cf238f"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ad4a9fc2e4a59628aca00743710cf238f template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ad4a9fc2e4a59628aca00743710cf238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for non polymorphic types. <br /></td></tr>
<tr class="memitem:ac84435d57b8944c536bb585c6516df09" id="r_ac84435d57b8944c536bb585c6516df09"><td class="memTemplParams" colspan="2"><a id="ac84435d57b8944c536bb585c6516df09" name="ac84435d57b8944c536bb585c6516df09"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:ac84435d57b8944c536bb585c6516df09 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ac84435d57b8944c536bb585c6516df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for non polymorphic types. <br /></td></tr>
<tr class="memitem:a97838af98c4fb9f5d42d928a1a4d64b5" id="r_a97838af98c4fb9f5d42d928a1a4d64b5"><td class="memTemplParams" colspan="2"><a id="a97838af98c4fb9f5d42d928a1a4d64b5" name="a97838af98c4fb9f5d42d928a1a4d64b5"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a97838af98c4fb9f5d42d928a1a4d64b5 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a97838af98c4fb9f5d42d928a1a4d64b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types. <br /></td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a" id="r_ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplParams" colspan="2"><a id="ac2dd1ac3ad73ad7203acdc21d7ea995a" name="ac2dd1ac3ad73ad7203acdc21d7ea995a"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr (wrapper implementation) <br /></td></tr>
<tr class="memitem:a2b046d36c3921f4bf7230ace29d26cd1" id="r_a2b046d36c3921f4bf7230ace29d26cd1"><td class="memTemplParams" colspan="2"><a id="a2b046d36c3921f4bf7230ace29d26cd1" name="a2b046d36c3921f4bf7230ace29d26cd1"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a2b046d36c3921f4bf7230ace29d26cd1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a2b046d36c3921f4bf7230ace29d26cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when user load and construct (wrapper implementation) <br /></td></tr>
<tr class="memitem:aca6796fd8ee95e0bd42b4cafe09c46c7" id="r_aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="memTemplParams" colspan="2"><a id="aca6796fd8ee95e0bd42b4cafe09c46c7" name="aca6796fd8ee95e0bd42b4cafe09c46c7"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:aca6796fd8ee95e0bd42b4cafe09c46c7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct (wrapper implementation) <br /></td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d" id="r_a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplParams" colspan="2"><a id="a7a5576cf5fa2dc553adca652003d232d" name="a7a5576cf5fa2dc553adca652003d232d"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:a7a5576cf5fa2dc553adca652003d232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr (wrapper implementation) <br /></td></tr>
<tr class="memitem:ae566380527639f7e35ec9144dff7350e" id="r_ae566380527639f7e35ec9144dff7350e"><td class="memTemplParams" colspan="2"><a id="ae566380527639f7e35ec9144dff7350e" name="ae566380527639f7e35ec9144dff7350e"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:ae566380527639f7e35ec9144dff7350e template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:ae566380527639f7e35ec9144dff7350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation) <br /></td></tr>
<tr class="memitem:a9e6b7247746d82f9ae810047390e8e61" id="r_a9e6b7247746d82f9ae810047390e8e61"><td class="memTemplParams" colspan="2"><a id="a9e6b7247746d82f9ae810047390e8e61" name="a9e6b7247746d82f9ae810047390e8e61"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a9e6b7247746d82f9ae810047390e8e61 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, <a class="el" href="../../df/d90/structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a9e6b7247746d82f9ae810047390e8e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when no load_and_construct (wrapper implementation) <br /></td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7" id="r_aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memTemplParams" colspan="2"><a id="aede65f937d9a4d9ebaef35db8c6e7ae7" name="aede65f937d9a4d9ebaef35db8c6e7ae7"></a>
template&lt;class Archive, typename T&gt; </td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, const std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::optional. <br /></td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca" id="r_a8be4f81090e80f115a2ac4041a9f16ca"><td class="memTemplParams" colspan="2"><a id="a8be4f81090e80f115a2ac4041a9f16ca" name="a8be4f81090e80f115a2ac4041a9f16ca"></a>
template&lt;class Archive, typename T&gt; </td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:a8be4f81090e80f115a2ac4041a9f16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::optional. <br /></td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d" id="r_ad178feaa536101818dbed91f516d7a3d"><td class="memTemplParams" colspan="2"><a id="ad178feaa536101818dbed91f516d7a3d" name="ad178feaa536101818dbed91f516d7a3d"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad178feaa536101818dbed91f516d7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract. <br /></td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8" id="r_ad6d7ca1d179cff040e96656467c821c8"><td class="memTemplParams" colspan="2"><a id="ad6d7ca1d179cff040e96656467c821c8" name="ad6d7ca1d179cff040e96656467c821c8"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad6d7ca1d179cff040e96656467c821c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017" id="r_a2e4daf2a3346e5b8f0b63685084ac017"><td class="memTemplParams" colspan="2"><a id="a2e4daf2a3346e5b8f0b63685084ac017" name="a2e4daf2a3346e5b8f0b63685084ac017"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a2e4daf2a3346e5b8f0b63685084ac017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc" id="r_a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="memTemplParams" colspan="2"><a id="a6abec1a5b79a96fac6e8a9452d6d5efc" name="a6abec1a5b79a96fac6e8a9452d6d5efc"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf" id="r_adc67713d049bdcac7a754c1f481641cf"><td class="memTemplParams" colspan="2"><a id="adc67713d049bdcac7a754c1f481641cf" name="adc67713d049bdcac7a754c1f481641cf"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:adc67713d049bdcac7a754c1f481641cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443" id="r_a65bf933f694e73578a268e7566c01443"><td class="memTemplParams" colspan="2"><a id="a65bf933f694e73578a268e7566c01443" name="a65bf933f694e73578a268e7566c01443"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a65bf933f694e73578a268e7566c01443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract. <br /></td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727" id="r_a9e704d8ad2170ff91ad710ed776d0727"><td class="memTemplParams" colspan="2"><a id="a9e704d8ad2170ff91ad710ed776d0727" name="a9e704d8ad2170ff91ad710ed776d0727"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a9e704d8ad2170ff91ad710ed776d0727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397" id="r_a0ec1b39135bb383c96bf8a072bfea397"><td class="memTemplParams" colspan="2"><a id="a0ec1b39135bb383c96bf8a072bfea397" name="a0ec1b39135bb383c96bf8a072bfea397"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a0ec1b39135bb383c96bf8a072bfea397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. <br /></td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be" id="r_a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplParams" colspan="2"><a id="a196f5ec0e6eb126730ee5fb7339fb8be" name="a196f5ec0e6eb126730ee5fb7339fb8be"></a>
template&lt;class Archive, class T, class C&gt; </td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::queue&lt; T, C &gt; const &amp;queue)</td></tr>
<tr class="memdesc:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::queue. <br /></td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525" id="r_a663f35fc093d002d4e07c0e965178525"><td class="memTemplParams" colspan="2"><a id="a663f35fc093d002d4e07c0e965178525" name="a663f35fc093d002d4e07c0e965178525"></a>
template&lt;class Archive, class T, class C&gt; </td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::queue&lt; T, C &gt; &amp;queue)</td></tr>
<tr class="memdesc:a663f35fc093d002d4e07c0e965178525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::queue. <br /></td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca" id="r_ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplParams" colspan="2"><a id="ad1957ae53b8fc963c0ed3e831deae7ca" name="ad1957ae53b8fc963c0ed3e831deae7ca"></a>
template&lt;class Archive, class T, class C, class Comp&gt; </td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; const &amp;priority_queue)</td></tr>
<tr class="memdesc:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::priority_queue. <br /></td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623" id="r_a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplParams" colspan="2"><a id="a9335c1a68710bfa8f49ae3a217b32623" name="a9335c1a68710bfa8f49ae3a217b32623"></a>
template&lt;class Archive, class T, class C, class Comp&gt; </td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; &amp;priority_queue)</td></tr>
<tr class="memdesc:a9335c1a68710bfa8f49ae3a217b32623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::priority_queue. <br /></td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878" id="r_a76a8cea063806602d60157cf1fb90878"><td class="memTemplParams" colspan="2"><a id="a76a8cea063806602d60157cf1fb90878" name="a76a8cea063806602d60157cf1fb90878"></a>
template&lt;class Archive, class K, class C, class A&gt; </td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::set&lt; K, C, A &gt; const &amp;set)</td></tr>
<tr class="memdesc:a76a8cea063806602d60157cf1fb90878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::set. <br /></td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5" id="r_a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplParams" colspan="2"><a id="a79a65f7506d96c59b25e5ad4bb6d6ad5" name="a79a65f7506d96c59b25e5ad4bb6d6ad5"></a>
template&lt;class Archive, class K, class C, class A&gt; </td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::set&lt; K, C, A &gt; &amp;set)</td></tr>
<tr class="memdesc:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::set. <br /></td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04" id="r_aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplParams" colspan="2"><a id="aba7424502dce9a6a12bc8b0c34c8fa04" name="aba7424502dce9a6a12bc8b0c34c8fa04"></a>
template&lt;class Archive, class K, class C, class A&gt; </td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; const &amp;multiset)</td></tr>
<tr class="memdesc:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::multiset. <br /></td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826" id="r_a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplParams" colspan="2"><a id="a6668a1fc6b49fcf9c53633e3eb385826" name="a6668a1fc6b49fcf9c53633e3eb385826"></a>
template&lt;class Archive, class K, class C, class A&gt; </td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; &amp;multiset)</td></tr>
<tr class="memdesc:a6668a1fc6b49fcf9c53633e3eb385826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::multiset. <br /></td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628" id="r_aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplParams" colspan="2"><a id="aca1f0d917ab00dd67f0b0e7d71737628" name="aca1f0d917ab00dd67f0b0e7d71737628"></a>
template&lt;class Archive, class T, class C&gt; </td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::stack&lt; T, C &gt; const &amp;stack)</td></tr>
<tr class="memdesc:aca1f0d917ab00dd67f0b0e7d71737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::stack. <br /></td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad" id="r_af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplParams" colspan="2"><a id="af7f082383d87633cf69bdf0ab3d450ad" name="af7f082383d87633cf69bdf0ab3d450ad"></a>
template&lt;class Archive, class T, class C&gt; </td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::stack&lt; T, C &gt; &amp;stack)</td></tr>
<tr class="memdesc:af7f082383d87633cf69bdf0ab3d450ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::stack. <br /></td></tr>
<tr class="memitem:a6c8e2f5032a22f0576cb08567f2d8e6f" id="r_a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="memTemplParams" colspan="2"><a id="a6c8e2f5032a22f0576cb08567f2d8e6f" name="a6c8e2f5032a22f0576cb08567f2d8e6f"></a>
template&lt;class Archive, class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:a6c8e2f5032a22f0576cb08567f2d8e6f template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported. <br /></td></tr>
<tr class="memitem:ac5719e2d913b81926159a1962ec95547" id="r_ac5719e2d913b81926159a1962ec95547"><td class="memTemplParams" colspan="2"><a id="ac5719e2d913b81926159a1962ec95547" name="ac5719e2d913b81926159a1962ec95547"></a>
template&lt;class Archive, class CharT, class Traits, class Alloc&gt; </td></tr>
<tr class="memitem:ac5719e2d913b81926159a1962ec95547 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:ac5719e2d913b81926159a1962ec95547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported. <br /></td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82" id="r_a660edef0c6b018675e109062d459dc82"><td class="memTemplParams" colspan="2"><a id="a660edef0c6b018675e109062d459dc82" name="a660edef0c6b018675e109062d459dc82"></a>
template&lt;class Archive, class ... Types&gt; </td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SERIALIZE_FUNCTION_NAME</b> (Archive &amp;ar, std::tuple&lt; Types... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a660edef0c6b018675e109062d459dc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::tuple. <br /></td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561" id="r_a220a6067b52ed669c0c151d76567b561"><td class="memTemplParams" colspan="2"><a id="a220a6067b52ed669c0c151d76567b561" name="a220a6067b52ed669c0c151d76567b561"></a>
template&lt;class Archive, class K, class H, class KE, class A&gt; </td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; const &amp;unordered_set)</td></tr>
<tr class="memdesc:a220a6067b52ed669c0c151d76567b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_set. <br /></td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba" id="r_af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplParams" colspan="2"><a id="af0b6234fc5a858bd294a833ccc9045ba" name="af0b6234fc5a858bd294a833ccc9045ba"></a>
template&lt;class Archive, class K, class H, class KE, class A&gt; </td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; &amp;unordered_set)</td></tr>
<tr class="memdesc:af0b6234fc5a858bd294a833ccc9045ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_set. <br /></td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889" id="r_a4385e91ff798d9c5f8c336470011b889"><td class="memTemplParams" colspan="2"><a id="a4385e91ff798d9c5f8c336470011b889" name="a4385e91ff798d9c5f8c336470011b889"></a>
template&lt;class Archive, class K, class H, class KE, class A&gt; </td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; const &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a4385e91ff798d9c5f8c336470011b889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_multiset. <br /></td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a" id="r_a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplParams" colspan="2"><a id="a7da956bad9ffcece46b8b3578a05567a" name="a7da956bad9ffcece46b8b3578a05567a"></a>
template&lt;class Archive, class K, class H, class KE, class A&gt; </td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a7da956bad9ffcece46b8b3578a05567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_multiset. <br /></td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73" id="r_a83c80c9e74c022531318b7df731c1f73"><td class="memTemplParams" colspan="2"><a id="a83c80c9e74c022531318b7df731c1f73" name="a83c80c9e74c022531318b7df731c1f73"></a>
template&lt;class Archive, class T1, class T2&gt; </td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SERIALIZE_FUNCTION_NAME</b> (Archive &amp;ar, std::pair&lt; T1, T2 &gt; &amp;pair)</td></tr>
<tr class="memdesc:a83c80c9e74c022531318b7df731c1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::pair. <br /></td></tr>
<tr class="memitem:afa97ef85d3c72b1bb9398c8c197fdd57" id="r_afa97ef85d3c72b1bb9398c8c197fdd57"><td class="memTemplParams" colspan="2"><a id="afa97ef85d3c72b1bb9398c8c197fdd57" name="afa97ef85d3c72b1bb9398c8c197fdd57"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:afa97ef85d3c72b1bb9398c8c197fdd57 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:afa97ef85d3c72b1bb9398c8c197fdd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray arithmetic types, using binary serialization, if supported. <br /></td></tr>
<tr class="memitem:a6dcea0f4702c0571eaac2b23a6ad8125" id="r_a6dcea0f4702c0571eaac2b23a6ad8125"><td class="memTemplParams" colspan="2"><a id="a6dcea0f4702c0571eaac2b23a6ad8125" name="a6dcea0f4702c0571eaac2b23a6ad8125"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a6dcea0f4702c0571eaac2b23a6ad8125 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a6dcea0f4702c0571eaac2b23a6ad8125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray arithmetic types, using binary serialization, if supported. <br /></td></tr>
<tr class="memitem:a8433d3fefce97949c3b895a50f9a8beb" id="r_a8433d3fefce97949c3b895a50f9a8beb"><td class="memTemplParams" colspan="2"><a id="a8433d3fefce97949c3b895a50f9a8beb" name="a8433d3fefce97949c3b895a50f9a8beb"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a8433d3fefce97949c3b895a50f9a8beb template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:a8433d3fefce97949c3b895a50f9a8beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray all other types. <br /></td></tr>
<tr class="memitem:a40b267f3c5857801c689781da4a74b5e" id="r_a40b267f3c5857801c689781da4a74b5e"><td class="memTemplParams" colspan="2"><a id="a40b267f3c5857801c689781da4a74b5e" name="a40b267f3c5857801c689781da4a74b5e"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a40b267f3c5857801c689781da4a74b5e template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a40b267f3c5857801c689781da4a74b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray all other types. <br /></td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c" id="r_a216f04eb0fd673671c399e76270d7f5c"><td class="memTemplParams" colspan="2"><a id="a216f04eb0fd673671c399e76270d7f5c" name="a216f04eb0fd673671c399e76270d7f5c"></a>
template&lt;class Archive, typename VariantType1, typename... VariantTypes&gt; </td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::variant&lt; VariantType1, VariantTypes... &gt; const &amp;variant)</td></tr>
<tr class="memdesc:a216f04eb0fd673671c399e76270d7f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::variant. <br /></td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e" id="r_ac7d7a06a029441ecec4314f9fa64813e"><td class="memTemplParams" colspan="2"><a id="ac7d7a06a029441ecec4314f9fa64813e" name="ac7d7a06a029441ecec4314f9fa64813e"></a>
template&lt;class Archive, typename... VariantTypes&gt; </td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:ac7d7a06a029441ecec4314f9fa64813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::variant. <br /></td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9" id="r_a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memTemplParams" colspan="2"><a id="a0e33aa2fc1bde7f59e9796f922cee3b9" name="a0e33aa2fc1bde7f59e9796f922cee3b9"></a>
template&lt;class Archive&gt; </td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SERIALIZE_FUNCTION_NAME</b> (Archive &amp;, std::monostate const &amp;)</td></tr>
<tr class="memdesc:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing a std::monostate. <br /></td></tr>
<tr class="memitem:adb789479aa9deae7b63d249f6dccccaf" id="r_adb789479aa9deae7b63d249f6dccccaf"><td class="memTemplParams" colspan="2"><a id="adb789479aa9deae7b63d249f6dccccaf" name="adb789479aa9deae7b63d249f6dccccaf"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:adb789479aa9deae7b63d249f6dccccaf template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:adb789479aa9deae7b63d249f6dccccaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. <br /></td></tr>
<tr class="memitem:a3a8c0283f25c71df86060789614c4cfe" id="r_a3a8c0283f25c71df86060789614c4cfe"><td class="memTemplParams" colspan="2"><a id="a3a8c0283f25c71df86060789614c4cfe" name="a3a8c0283f25c71df86060789614c4cfe"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a3a8c0283f25c71df86060789614c4cfe template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a3a8c0283f25c71df86060789614c4cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. <br /></td></tr>
<tr class="memitem:a4ae26efa958e82169d5f813bda0ad1c5" id="r_a4ae26efa958e82169d5f813bda0ad1c5"><td class="memTemplParams" colspan="2"><a id="a4ae26efa958e82169d5f813bda0ad1c5" name="a4ae26efa958e82169d5f813bda0ad1c5"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a4ae26efa958e82169d5f813bda0ad1c5 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value)&amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a4ae26efa958e82169d5f813bda0ad1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types. <br /></td></tr>
<tr class="memitem:a0aa0955bf32e5651828e110004b6dc5d" id="r_a0aa0955bf32e5651828e110004b6dc5d"><td class="memTemplParams" colspan="2"><a id="a0aa0955bf32e5651828e110004b6dc5d" name="a0aa0955bf32e5651828e110004b6dc5d"></a>
template&lt;class Archive, class T, class A&gt; </td></tr>
<tr class="memitem:a0aa0955bf32e5651828e110004b6dc5d template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value)&amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a0aa0955bf32e5651828e110004b6dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types. <br /></td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7" id="r_a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplParams" colspan="2"><a id="a76b613c5fc7ae5ec8f8216a6337955a7" name="a76b613c5fc7ae5ec8f8216a6337955a7"></a>
template&lt;class Archive, class A&gt; </td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; bool, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types. <br /></td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8" id="r_a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplParams" colspan="2"><a id="a09c7d1d922569ba782c8ec6d8f79b3e8" name="a09c7d1d922569ba782c8ec6d8f79b3e8"></a>
template&lt;class Archive, class A&gt; </td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::vector&lt; bool, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types. <br /></td></tr>
<tr class="memitem:a5bfb9090edc7c741335fba284e462a49" id="r_a5bfb9090edc7c741335fba284e462a49"><td class="memTemplParams" colspan="2"><a id="a5bfb9090edc7c741335fba284e462a49" name="a5bfb9090edc7c741335fba284e462a49"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a5bfb9090edc7c741335fba284e462a49 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_nvp</b> (std::string const &amp;name, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a5bfb9090edc7c741335fba284e462a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a name value pair. <br /></td></tr>
<tr class="memitem:a4ae230f9f8c3d979df8daa95ef6cbcdc" id="r_a4ae230f9f8c3d979df8daa95ef6cbcdc"><td class="memTemplParams" colspan="2"><a id="a4ae230f9f8c3d979df8daa95ef6cbcdc" name="a4ae230f9f8c3d979df8daa95ef6cbcdc"></a>
template&lt;class T&gt; </td></tr>
<tr class="memitem:a4ae230f9f8c3d979df8daa95ef6cbcdc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_nvp</b> (const char *name, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a4ae230f9f8c3d979df8daa95ef6cbcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a name value pair. <br /></td></tr>
<tr class="memitem:a593d161603775672f91ab448ef65083e" id="r_a593d161603775672f91ab448ef65083e"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a593d161603775672f91ab448ef65083e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html#a593d161603775672f91ab448ef65083e">binary_data</a> (T &amp;&amp;data, size_t size)</td></tr>
<tr class="memdesc:a593d161603775672f91ab448ef65083e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to create binary data for both const and non const pointers.  <br /></td></tr>
<tr class="memitem:a4d4b256b14671c8270d06f40e4c4a077" id="r_a4d4b256b14671c8270d06f40e4c4a077"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a4d4b256b14671c8270d06f40e4c4a077 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html#a4d4b256b14671c8270d06f40e4c4a077">make_size_tag</a> (T &amp;&amp;sz)</td></tr>
<tr class="memdesc:a4d4b256b14671c8270d06f40e4c4a077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a size tag from some variable.  <br /></td></tr>
<tr class="memitem:afc913c738d15fc5dd7f4a7a20edb5225" id="r_afc913c738d15fc5dd7f4a7a20edb5225"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:afc913c738d15fc5dd7f4a7a20edb5225 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html#afc913c738d15fc5dd7f4a7a20edb5225">defer</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:afc913c738d15fc5dd7f4a7a20edb5225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks data for deferred serialization.  <br /></td></tr>
<tr class="memitem:a7b7b9b5e674a363fb8fd9baca2ca73ce" id="r_a7b7b9b5e674a363fb8fd9baca2ca73ce"><td class="memTemplParams" colspan="2"><a id="a7b7b9b5e674a363fb8fd9baca2ca73ce" name="a7b7b9b5e674a363fb8fd9baca2ca73ce"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a7b7b9b5e674a363fb8fd9baca2ca73ce template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; Archive,<a class="el" href="../../d9/d9e/classcereal_1_1_binary_input_archive.html">::cereal::BinaryInputArchive</a> &gt;::value||std::is_same&lt; Archive,<a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html">::cereal::BinaryOutputArchive</a> &gt;::value, T &amp;&amp; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>make_nvp</b> (const char *, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a7b7b9b5e674a363fb8fd9baca2ca73ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of make_nvp&lt;&gt; that simply forwards the value for binary archives. <br /></td></tr>
<tr class="memitem:a4f76432ed952dbfdc7e7973fb0d16ac1" id="r_a4f76432ed952dbfdc7e7973fb0d16ac1"><td class="memTemplParams" colspan="2"><a id="a4f76432ed952dbfdc7e7973fb0d16ac1" name="a4f76432ed952dbfdc7e7973fb0d16ac1"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a4f76432ed952dbfdc7e7973fb0d16ac1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; Archive,<a class="el" href="../../d9/d9e/classcereal_1_1_binary_input_archive.html">::cereal::BinaryInputArchive</a> &gt;::value &amp;&amp;!std::is_same&lt; Archive,<a class="el" href="../../dd/d4d/classcereal_1_1_binary_output_archive.html">::cereal::BinaryOutputArchive</a> &gt;::value, <a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>make_nvp</b> (const char *name, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a4f76432ed952dbfdc7e7973fb0d16ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of make_nvp&lt;&gt; that actually creates an nvp for non-binary archives. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a0e01d80aaafe0efb12b75abdee310ae4" name="a0e01d80aaafe0efb12b75abdee310ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01d80aaafe0efb12b75abdee310ae4">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e01d80aaafe0efb12b75abdee310ae4">cereal::size_type</a> = <a class="el" href="../../db/dbe/macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type used by cereal. </p>
<p>To ensure compatability between 32, 64, etc bit machines, we need to use a fixed size type instead of size_t, which may vary from machine to machine.</p>
<p>The default value for CEREAL_SIZE_TYPE is specified in <a class="el" href="../../db/dbe/macros_8hpp.html" title="Preprocessor macros that can customise the cereal library.">cereal/macros.hpp</a> </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a95185aa9f39e4ac382bb6631beb68a67" name="a95185aa9f39e4ac382bb6631beb68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95185aa9f39e4ac382bb6631beb68a67">&#9670;&#160;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a95185aa9f39e4ac382bb6631beb68a67">cereal::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special flags for archives. </p>
<p>AllowEmptyClassElision This allows for empty classes to be serialized even if they do not provide a serialization function. Classes with no data members are considered to be empty. Be warned that if this is enabled and you attempt to serialize an empty class with improperly formed serialize or load/save functions, no static error will occur - the error will propogate silently and your intended serialization functions may not be called. You can manually ensure that your classes that have custom serialization are correct by using the traits is_output_serializable and is_input_serializable in <a class="el" href="../../df/d73/traits_8hpp.html" title="Internal type trait support.">cereal/details/traits.hpp</a>. </p>

</div>
</div>
<a id="ac28bb730353e53b3066cc679e63bb108" name="ac28bb730353e53b3066cc679e63bb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28bb730353e53b3066cc679e63bb108">&#9670;&#160;</a></span>specialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T, specialization S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class specialization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A specifier used in conjunction with <a class="el" href="../../d7/d96/structcereal_1_1specialize.html" title="A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.">cereal::specialize</a> to disambiguate serialization in special cases </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5c962df81c2ad99813597b6238e3e17d" name="a5c962df81c2ad99813597b6238e3e17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c962df81c2ad99813597b6238e3e17d">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="../../d7/d2a/structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loading for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a54c9c74df6d91319b01128690322690a" name="a54c9c74df6d91319b01128690322690a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c9c74df6d91319b01128690322690a">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="../../d7/d28/structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="../../d9/d73/structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saving for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a676a85ac8cfcd512a743f930a10b6770" name="a676a85ac8cfcd512a743f930a10b6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676a85ac8cfcd512a743f930a10b6770">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for raw pointers. </p>
<p>This exists only to throw a static_assert to let users know we don't support raw pointers. </p>

</div>
</div>
<a id="a64ec0a04e5dc57a58de5e78b5a87b8d3" name="a64ec0a04e5dc57a58de5e78b5a87b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to binary. </p>
<p>Serializing NVP types to portable binary. </p>

</div>
</div>
<a id="ac5fb9b1468920e7e23cb2817e65fed4a" name="ac5fb9b1468920e7e23cb2817e65fed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb9b1468920e7e23cb2817e65fed4a">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing SizeTags to binary. </p>
<p>Serializing SizeTags to portable binary. </p>

</div>
</div>
<a id="a1153b7ce7ffbb86e2c81e076a252938e" name="a1153b7ce7ffbb86e2c81e076a252938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153b7ce7ffbb86e2c81e076a252938e">&#9670;&#160;</a></span>epilogue() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a type is serialized to tear down any special archive state for processing some type </p>

</div>
</div>
<a id="a7ae425e0a66c44b7d39b16d0a6a7f0d9" name="a7ae425e0a66c44b7d39b16d0a6a7f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae425e0a66c44b7d39b16d0a6a7f0d9">&#9670;&#160;</a></span>epilogue() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a99326c431920835d61e5bfc51b865f22" name="a99326c431920835d61e5bfc51b865f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99326c431920835d61e5bfc51b865f22">&#9670;&#160;</a></span>epilogue() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d7b/classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ae0c0c3b1ea7aadc84af34b815bfad6a6" name="ae0c0c3b1ea7aadc84af34b815bfad6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c0c3b1ea7aadc84af34b815bfad6a6">&#9670;&#160;</a></span>epilogue() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a3bec173adc6146ecc712921c2d257ade" name="a3bec173adc6146ecc712921c2d257ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec173adc6146ecc712921c2d257ade">&#9670;&#160;</a></span>epilogue() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ab92526cf5d3f4a642d918a027d2e4567" name="ab92526cf5d3f4a642d918a027d2e4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92526cf5d3f4a642d918a027d2e4567">&#9670;&#160;</a></span>epilogue() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON </p>

</div>
</div>
<a id="abb6adc568591c0a525f2c16ea5912c5b" name="abb6adc568591c0a525f2c16ea5912c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6adc568591c0a525f2c16ea5912c5b">&#9670;&#160;</a></span>epilogue() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value, !<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives (except minimal types) </p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a70bbce1604367ea45c07dc677186ed64" name="a70bbce1604367ea45c07dc677186ed64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bbce1604367ea45c07dc677186ed64">&#9670;&#160;</a></span>epilogue() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/dc4/classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="acb1f17a3cae999a9be34889fd2c509a0" name="acb1f17a3cae999a9be34889fd2c509a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1f17a3cae999a9be34889fd2c509a0">&#9670;&#160;</a></span>epilogue() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a906ef65c3ab455598f768431bcd5f37d" name="a906ef65c3ab455598f768431bcd5f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906ef65c3ab455598f768431bcd5f37d">&#9670;&#160;</a></span>epilogue() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ac3700f36066026da589faa60fed7ca53" name="ac3700f36066026da589faa60fed7ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3700f36066026da589faa60fed7ca53">&#9670;&#160;</a></span>epilogue() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="a16ca55f7d5556527de1584198ea3c414" name="a16ca55f7d5556527de1584198ea3c414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca55f7d5556527de1584198ea3c414">&#9670;&#160;</a></span>epilogue() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value||<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="a8093b5f7cfd618fae6350ef7b2c09453" name="a8093b5f7cfd618fae6350ef7b2c09453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8093b5f7cfd618fae6350ef7b2c09453">&#9670;&#160;</a></span>prologue() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a type is serialized to set up any special archive state for processing some type</p>
<p>If designing a serializer that needs to set up any kind of special state or output extra information for a type, specialize this function for the archive type and the types that require the extra information. </p>

</div>
</div>
<a id="ab4eb0997ec3815e2be77c35351d02cf7" name="ab4eb0997ec3815e2be77c35351d02cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb0997ec3815e2be77c35351d02cf7">&#9670;&#160;</a></span>prologue() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="ac267b8915a13f4433fc25aa9d310ee40" name="ac267b8915a13f4433fc25aa9d310ee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267b8915a13f4433fc25aa9d310ee40">&#9670;&#160;</a></span>prologue() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a5f7ec98da774f9e0af596620859d8ccb" name="a5f7ec98da774f9e0af596620859d8ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ec98da774f9e0af596620859d8ccb">&#9670;&#160;</a></span>prologue() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON, they just indicate that the current node should be made into an array </p>

</div>
</div>
<a id="aba2924cd871a88c20023171f74a68d39" name="aba2924cd871a88c20023171f74a68d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2924cd871a88c20023171f74a68d39">&#9670;&#160;</a></span>prologue() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !<a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value, !<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dad/classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives (except minimal types) </p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a6124c7acd34d3740cbedd39559da73c3" name="a6124c7acd34d3740cbedd39559da73c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6124c7acd34d3740cbedd39559da73c3">&#9670;&#160;</a></span>prologue() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de7/classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a2582cc8477f9482910fc5733e13f75f7" name="a2582cc8477f9482910fc5733e13f75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582cc8477f9482910fc5733e13f75f7">&#9670;&#160;</a></span>prologue() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d90/classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="adbb541e9594201d78a04cb11ad806ba0" name="adbb541e9594201d78a04cb11ad806ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb541e9594201d78a04cb11ad806ba0">&#9670;&#160;</a></span>prologue() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/ddf/classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="af751c02a4443b571fee21416a4b899c1" name="af751c02a4443b571fee21416a4b899c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751c02a4443b571fee21416a4b899c1">&#9670;&#160;</a></span>prologue() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, traits::DisableIf&lt; <a class="el" href="../../de/d1c/structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value||<a class="el" href="../../db/d07/structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;::value &gt; = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dd3/classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML output archives (except minimal types) </p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../da/da6/namespacecereal.html">cereal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
