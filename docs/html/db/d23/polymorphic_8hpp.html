<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HODLRdD: lib/cereal/types/polymorphic.hpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HODLRdD<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Hierarchically off-diagonal low-rank matrix in d dimensions (HODLR d D), a black-box fast algorithm for particle simulations in d dimensions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('db/d23/polymorphic_8hpp.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">polymorphic.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Support for pointers to polymorphic base classes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="../../d5/d17/cereal_8hpp_source.html">cereal/cereal.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/d3e/memory_8hpp_source.html">cereal/types/memory.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/d3f/util_8hpp_source.html">cereal/details/util.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/df3/helpers_8hpp_source.html">cereal/details/helpers.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../df/d73/traits_8hpp_source.html">cereal/details/traits.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d7/d11/polymorphic__impl_8hpp_source.html">cereal/details/polymorphic_impl.hpp</a>&quot;</code><br />
</div>
<p><a href="../../db/d23/polymorphic_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:cereal" id="r_cereal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da6/namespacecereal.html">cereal</a></td></tr>
<tr class="memdesc:da/da6/namespacecereal"><td class="mdescLeft">&#160;</td><td class="mdescRight">in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a94967009fc480f164511d6bd369f5329" id="r_a94967009fc480f164511d6bd369f5329"><td class="memItemLeft" align="right" valign="top"><a id="a94967009fc480f164511d6bd369f5329" name="a94967009fc480f164511d6bd369f5329"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CEREAL_STATIC_CONSTEXPR</b>&#160;&#160;&#160;static constexpr</td></tr>
<tr class="memitem:aad63585dab771e2dea41bb102c4d7a4c" id="r_aad63585dab771e2dea41bb102c4d7a4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad63585dab771e2dea41bb102c4d7a4c">CEREAL_REGISTER_TYPE</a>(...)</td></tr>
<tr class="memdesc:aad63585dab771e2dea41bb102c4d7a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a derived polymorphic type with cereal.  <br /></td></tr>
<tr class="memitem:a84efbe4f256827ca26fe3d86d8bd528c" id="r_a84efbe4f256827ca26fe3d86d8bd528c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84efbe4f256827ca26fe3d86d8bd528c">CEREAL_REGISTER_TYPE_WITH_NAME</a>(T,  Name)</td></tr>
<tr class="memitem:a5d730928a52a379ad0d6f2dcdee07953" id="r_a5d730928a52a379ad0d6f2dcdee07953"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d730928a52a379ad0d6f2dcdee07953">CEREAL_REGISTER_POLYMORPHIC_RELATION</a>(Base,  Derived)</td></tr>
<tr class="memdesc:a5d730928a52a379ad0d6f2dcdee07953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the base-derived relationship for a polymorphic type.  <br /></td></tr>
<tr class="memitem:a01ebe0f840ac20c307f64622384e4dae" id="r_a01ebe0f840ac20c307f64622384e4dae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ebe0f840ac20c307f64622384e4dae">CEREAL_REGISTER_DYNAMIC_INIT</a>(LibName)</td></tr>
<tr class="memitem:a8e0d5df9830c0ed7c60451cf2f873ff5" id="r_a8e0d5df9830c0ed7c60451cf2f873ff5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0d5df9830c0ed7c60451cf2f873ff5">CEREAL_FORCE_DYNAMIC_INIT</a>(LibName)</td></tr>
<tr class="memitem:a6a90af3fca239017978477a753225101" id="r_a6a90af3fca239017978477a753225101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a90af3fca239017978477a753225101">UNREGISTERED_POLYMORPHIC_EXCEPTION</a>(LoadSave,  Name)</td></tr>
<tr class="memdesc:a6a90af3fca239017978477a753225101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error message used for unregistered polymorphic types.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a78e7f83c5bd8746da7563d1bdb145cdf" id="r_a78e7f83c5bd8746da7563d1bdb145cdf"><td class="memTemplParams" colspan="2"><a id="a78e7f83c5bd8746da7563d1bdb145cdf" name="a78e7f83c5bd8746da7563d1bdb145cdf"></a>
template&lt;class Archive&gt; </td></tr>
<tr class="memitem:a78e7f83c5bd8746da7563d1bdb145cdf template"><td class="memItemLeft" align="right" valign="top">typename::cereal::detail::InputBindingMap&lt; Archive &gt;::Serializers&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::polymorphic_detail::getInputBinding</b> (Archive &amp;ar, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a78e7f83c5bd8746da7563d1bdb145cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an input binding from the given archive by deserializing the type meta data. <br /></td></tr>
<tr class="memitem:a6fa1b152a43117a484c4a11f382cc07a" id="r_a6fa1b152a43117a484c4a11f382cc07a"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a6fa1b152a43117a484c4a11f382cc07a template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="../../d1/dec/structcereal_1_1traits_1_1is__default__constructible.html">traits::is_default_constructible</a>&lt; T &gt;::value||<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa1b152a43117a484c4a11f382cc07a">cereal::polymorphic_detail::serialize_wrapper</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a6fa1b152a43117a484c4a11f382cc07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <br /></td></tr>
<tr class="memitem:a7af7795b2bcb38d405583464d6089deb" id="r_a7af7795b2bcb38d405583464d6089deb"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a7af7795b2bcb38d405583464d6089deb template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="../../d1/dec/structcereal_1_1traits_1_1is__default__constructible.html">traits::is_default_constructible</a>&lt; T &gt;::value||<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7af7795b2bcb38d405583464d6089deb">cereal::polymorphic_detail::serialize_wrapper</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a7af7795b2bcb38d405583464d6089deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <br /></td></tr>
<tr class="memitem:a23063c31a89bfb2305ae5b0e9a416ce1" id="r_a23063c31a89bfb2305ae5b0e9a416ce1"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a23063c31a89bfb2305ae5b0e9a416ce1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="../../d1/dec/structcereal_1_1traits_1_1is__default__constructible.html">traits::is_default_constructible</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value)||std::is_abstract&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23063c31a89bfb2305ae5b0e9a416ce1">cereal::polymorphic_detail::serialize_wrapper</a> (Archive &amp;, std::shared_ptr&lt; T &gt; &amp;, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a23063c31a89bfb2305ae5b0e9a416ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <br /></td></tr>
<tr class="memitem:a482cf9bb75c7d20d21e8ea9e887e2f67" id="r_a482cf9bb75c7d20d21e8ea9e887e2f67"><td class="memTemplParams" colspan="2">template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a482cf9bb75c7d20d21e8ea9e887e2f67 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="../../d1/dec/structcereal_1_1traits_1_1is__default__constructible.html">traits::is_default_constructible</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="../../d0/dee/structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value)||std::is_abstract&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a482cf9bb75c7d20d21e8ea9e887e2f67">cereal::polymorphic_detail::serialize_wrapper</a> (Archive &amp;, std::unique_ptr&lt; T, D &gt; &amp;, std::uint32_t const nameid)</td></tr>
<tr class="memdesc:a482cf9bb75c7d20d21e8ea9e887e2f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee.  <br /></td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d" id="r_ad178feaa536101818dbed91f516d7a3d"><td class="memTemplParams" colspan="2"><a id="ad178feaa536101818dbed91f516d7a3d" name="ad178feaa536101818dbed91f516d7a3d"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad178feaa536101818dbed91f516d7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract. <br /></td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8" id="r_ad6d7ca1d179cff040e96656467c821c8"><td class="memTemplParams" colspan="2"><a id="ad6d7ca1d179cff040e96656467c821c8" name="ad6d7ca1d179cff040e96656467c821c8"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad6d7ca1d179cff040e96656467c821c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017" id="r_a2e4daf2a3346e5b8f0b63685084ac017"><td class="memTemplParams" colspan="2"><a id="a2e4daf2a3346e5b8f0b63685084ac017" name="a2e4daf2a3346e5b8f0b63685084ac017"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a2e4daf2a3346e5b8f0b63685084ac017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc" id="r_a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="memTemplParams" colspan="2"><a id="a6abec1a5b79a96fac6e8a9452d6d5efc" name="a6abec1a5b79a96fac6e8a9452d6d5efc"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf" id="r_adc67713d049bdcac7a754c1f481641cf"><td class="memTemplParams" colspan="2"><a id="adc67713d049bdcac7a754c1f481641cf" name="adc67713d049bdcac7a754c1f481641cf"></a>
template&lt;class Archive, class T&gt; </td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:adc67713d049bdcac7a754c1f481641cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types. <br /></td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443" id="r_a65bf933f694e73578a268e7566c01443"><td class="memTemplParams" colspan="2"><a id="a65bf933f694e73578a268e7566c01443" name="a65bf933f694e73578a268e7566c01443"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a65bf933f694e73578a268e7566c01443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract. <br /></td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727" id="r_a9e704d8ad2170ff91ad710ed776d0727"><td class="memTemplParams" colspan="2"><a id="a9e704d8ad2170ff91ad710ed776d0727" name="a9e704d8ad2170ff91ad710ed776d0727"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_SAVE_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a9e704d8ad2170ff91ad710ed776d0727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract. <br /></td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397" id="r_a0ec1b39135bb383c96bf8a072bfea397"><td class="memTemplParams" colspan="2"><a id="a0ec1b39135bb383c96bf8a072bfea397" name="a0ec1b39135bb383c96bf8a072bfea397"></a>
template&lt;class Archive, class T, class D&gt; </td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>cereal::CEREAL_LOAD_FUNCTION_NAME</b> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a0ec1b39135bb383c96bf8a072bfea397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for pointers to polymorphic base classes. </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="a8e0d5df9830c0ed7c60451cf2f873ff5" name="a8e0d5df9830c0ed7c60451cf2f873ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0d5df9830c0ed7c60451cf2f873ff5">&#9670;&#160;</a></span>CEREAL_FORCE_DYNAMIC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_FORCE_DYNAMIC_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>LibName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code hl_namespace" href="../../da/da6/namespacecereal.html">cereal</a> {                                       \</div>
<div class="line">  <span class="keyword">namespace </span>detail {                                       \</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_define" href="../../d4/d66/static__object_8hpp.html#afde52a096f363ebe6869a9c0f9ef4cbb">CEREAL_DLL_EXPORT</a> dynamic_init_dummy_##LibName(); \</div>
<div class="line">  } <span class="comment">/* end detail */</span>                                       \</div>
<div class="line">  } <span class="comment">/* end cereal */</span>                                       \</div>
<div class="line">  <span class="keyword">namespace </span>{                                              \</div>
<div class="line">    <span class="keyword">struct </span>dynamic_init_##LibName {                        \</div>
<div class="line">      dynamic_init_##LibName() {                           \</div>
<div class="line">        ::cereal::detail::dynamic_init_dummy_##LibName();  \</div>
<div class="line">      }                                                    \</div>
<div class="line">    } dynamic_init_instance_##LibName;                     \</div>
<div class="line">  } <span class="comment">/* end anonymous namespace */</span></div>
<div class="ttc" id="anamespacecereal_html"><div class="ttname"><a href="../../da/da6/namespacecereal.html">cereal</a></div><div class="ttdoc">in certain simple scenarios. They should probably not be used if maximizing performance is the main o...</div><div class="ttdef"><b>Definition</b> access.hpp:42</div></div>
<div class="ttc" id="astatic__object_8hpp_html_afde52a096f363ebe6869a9c0f9ef4cbb"><div class="ttname"><a href="../../d4/d66/static__object_8hpp.html#afde52a096f363ebe6869a9c0f9ef4cbb">CEREAL_DLL_EXPORT</a></div><div class="ttdeci">#define CEREAL_DLL_EXPORT</div><div class="ttdoc">Prevent link optimization from removing non-referenced static objects.</div><div class="ttdef"><b>Definition</b> static_object.hpp:51</div></div>
</div><!-- fragment --><p>Forces dynamic initialization of polymorphic support in a previously registered source file</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a01ebe0f840ac20c307f64622384e4dae">CEREAL_REGISTER_DYNAMIC_INIT</a></dd></dl>
<p>See CEREAL_REGISTER_DYNAMIC_INIT for detailed explanation of how this macro should be used. The name used should match that for CEREAL_REGISTER_DYNAMIC_INIT. </p>

</div>
</div>
<a id="a01ebe0f840ac20c307f64622384e4dae" name="a01ebe0f840ac20c307f64622384e4dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ebe0f840ac20c307f64622384e4dae">&#9670;&#160;</a></span>CEREAL_REGISTER_DYNAMIC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_DYNAMIC_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>LibName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code hl_namespace" href="../../da/da6/namespacecereal.html">cereal</a> {                                         \</div>
<div class="line">  <span class="keyword">namespace </span>detail {                                         \</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_define" href="../../d4/d66/static__object_8hpp.html#afde52a096f363ebe6869a9c0f9ef4cbb">CEREAL_DLL_EXPORT</a> dynamic_init_dummy_##LibName() {} \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span></div>
</div><!-- fragment --><p>Adds a way to force initialization of a translation unit containing calls to CEREAL_REGISTER_TYPE</p>
<p>In C++, dynamic initialization of non-local variables of a translation unit may be deferred until "the first odr-use of any function or variable
defined in the same translation unit as the variable to be initialized."</p>
<p>Informally, odr-use means that your program takes the address of or binds a reference directly to an object, which must have a definition.</p>
<p>Since polymorphic type support in cereal relies on the dynamic initialization of certain global objects happening before serialization is performed, it is important to ensure that something from files that call CEREAL_REGISTER_TYPE is odr-used before serialization occurs, otherwise the registration will never take place. This may often be the case when serialization is built as a shared library external from your main program.</p>
<p>This macro, with any name of your choosing, should be placed into the source file that contains calls to CEREAL_REGISTER_TYPE.</p>
<p>Its counterpart, CEREAL_FORCE_DYNAMIC_INIT, should be placed in its associated header file such that it is included in the translation units (source files) in which you want the registration to appear. </p>

</div>
</div>
<a id="a5d730928a52a379ad0d6f2dcdee07953" name="a5d730928a52a379ad0d6f2dcdee07953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d730928a52a379ad0d6f2dcdee07953">&#9670;&#160;</a></span>CEREAL_REGISTER_POLYMORPHIC_RELATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_POLYMORPHIC_RELATION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Derived</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code hl_namespace" href="../../da/da6/namespacecereal.html">cereal</a> {                                                            \</div>
<div class="line">  <span class="keyword">namespace </span>detail {                                                            \</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt;                                                                   \</div>
<div class="line">  <span class="keyword">struct </span>PolymorphicRelation&lt;Base, Derived&gt;                                     \</div>
<div class="line">  { <span class="keyword">static</span> <span class="keywordtype">void</span> bind() { RegisterPolymorphicCaster&lt;Base, Derived&gt;::bind(); } }; \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span></div>
</div><!-- fragment -->
<p>Registers the base-derived relationship for a polymorphic type. </p>
<p>When polymorphic serialization occurs, cereal needs to know how to properly cast between derived and base types for the polymorphic type. Normally this happens automatically whenever <a class="el" href="../../df/d11/structcereal_1_1base__class.html" title="Casts a derived class to its non-virtual base class in a way that safely supports abstract classes.">cereal::base_class</a> or <a class="el" href="../../d3/d81/structcereal_1_1virtual__base__class.html" title="Casts a derived class to its virtual base class in a way that allows cereal to track inheritance.">cereal::virtual_base_class</a> are used to serialize a base class. In cases where neither of these is ever called but a base class still exists, this explicit registration is required.</p>
<p>The Derived class should be the most derived type that will be serialized, and the Base type any possible base that has not been covered under a base class serialization that will be used to store a Derived pointer.</p>
<p>Placement of this is the same as for CEREAL_REGISTER_TYPE. </p>

</div>
</div>
<a id="aad63585dab771e2dea41bb102c4d7a4c" name="aad63585dab771e2dea41bb102c4d7a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad63585dab771e2dea41bb102c4d7a4c">&#9670;&#160;</a></span>CEREAL_REGISTER_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_TYPE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code hl_namespace" href="../../da/da6/namespacecereal.html">cereal</a> {                                                     \</div>
<div class="line">  <span class="keyword">namespace </span>detail {                                                     \</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt;                                                            \</div>
<div class="line">  <span class="keyword">struct </span>binding_name&lt;__VA_ARGS__&gt;                                       \</div>
<div class="line">  {                                                                      \</div>
<div class="line">    CEREAL_STATIC_CONSTEXPR <span class="keywordtype">char</span> <span class="keyword">const</span> * name() { <span class="keywordflow">return</span> #__VA_ARGS__; } \</div>
<div class="line">  };                                                                     \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span>                                               \</div>
<div class="line">  CEREAL_BIND_TO_ARCHIVES(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Registers a derived polymorphic type with cereal. </p>
<p>Polymorphic types must be registered before smart pointers to them can be serialized. Note that base classes do not need to be registered.</p>
<p>Registering a type lets cereal know how to properly serialize it when a smart pointer to a base object is used in conjunction with a derived class.</p>
<p>This assumes that all relevant archives have also previously been registered. Registration for archives is usually done in the header file in which they are defined. This means that type registration needs to happen after specific archives to be used are included.</p>
<p>It is recommended that type registration be done in the header file in which the type is declared.</p>
<p>Registration can also be placed in a source file, but this may require the use of the CEREAL_REGISTER_DYNAMIC_INIT macro (see below).</p>
<p>Registration may be called repeatedly for the same type in different translation units to add support for additional archives if they are not initially available (included and registered).</p>
<p>When building serialization support as a DLL on Windows, registration must happen in the header file. On Linux and Mac things should still work properly if placed in a source file, but see the above comments on registering in source files.</p>
<p>Polymorphic support in cereal requires RTTI to be enabled </p>

</div>
</div>
<a id="a84efbe4f256827ca26fe3d86d8bd528c" name="a84efbe4f256827ca26fe3d86d8bd528c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84efbe4f256827ca26fe3d86d8bd528c">&#9670;&#160;</a></span>CEREAL_REGISTER_TYPE_WITH_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_REGISTER_TYPE_WITH_NAME</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code hl_namespace" href="../../da/da6/namespacecereal.html">cereal</a> {                                                \</div>
<div class="line">  <span class="keyword">namespace </span>detail {                                                \</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt;                                                       \</div>
<div class="line">  <span class="keyword">struct </span>binding_name&lt;T&gt;                                            \</div>
<div class="line">  { CEREAL_STATIC_CONSTEXPR <span class="keywordtype">char</span> <span class="keyword">const</span> * name() { <span class="keywordflow">return</span> Name; } }; \</div>
<div class="line">  } } <span class="comment">/* end namespaces */</span>                                          \</div>
<div class="line">  CEREAL_BIND_TO_ARCHIVES(T)</div>
</div><!-- fragment --><p>Registers a polymorphic type with cereal, giving it a user defined name</p>
<p>In some cases the default name used with CEREAL_REGISTER_TYPE (the name of the type) may not be suitable. This macro allows any name to be associated with the type. The name should be unique </p>

</div>
</div>
<a id="a6a90af3fca239017978477a753225101" name="a6a90af3fca239017978477a753225101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a90af3fca239017978477a753225101">&#9670;&#160;</a></span>UNREGISTERED_POLYMORPHIC_EXCEPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNREGISTERED_POLYMORPHIC_EXCEPTION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>LoadSave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">      <span class="keywordflow">throw</span> <a class="code hl_struct" href="../../d0/df3/structcereal_1_1_exception.html">cereal::Exception</a>(<span class="stringliteral">&quot;Trying to &quot;</span> #LoadSave <span class="stringliteral">&quot; an unregistered polymorphic type (&quot;</span> + Name + <span class="stringliteral">&quot;).\n&quot;</span>                                          \</div>
<div class="line">                              <span class="stringliteral">&quot;Make sure your type is registered with CEREAL_REGISTER_TYPE and that the archive &quot;</span>                                   \</div>
<div class="line">                              <span class="stringliteral">&quot;you are using was included (and registered with CEREAL_REGISTER_ARCHIVE) prior to calling CEREAL_REGISTER_TYPE.\n&quot;</span>   \</div>
<div class="line">                              <span class="stringliteral">&quot;If your type is already registered and you still see this error, you may need to use CEREAL_REGISTER_DYNAMIC_INIT.&quot;</span>);</div>
<div class="ttc" id="astructcereal_1_1_exception_html"><div class="ttname"><a href="../../d0/df3/structcereal_1_1_exception.html">cereal::Exception</a></div><div class="ttdoc">An exception class thrown when things go wrong at runtime.</div><div class="ttdef"><b>Definition</b> helpers.hpp:49</div></div>
</div><!-- fragment -->
<p>Error message used for unregistered polymorphic types. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a23063c31a89bfb2305ae5b0e9a416ce1" name="a23063c31a89bfb2305ae5b0e9a416ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23063c31a89bfb2305ae5b0e9a416ce1">&#9670;&#160;</a></span>serialize_wrapper() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!traits::is_default_constructible&lt; T &gt;::value &amp;&amp;!traits::has_load_and_construct&lt; T, Archive &gt;::value)||std::is_abstract&lt; T &gt;::value, bool &gt;::type cereal::polymorphic_detail::serialize_wrapper </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t const</td>          <td class="paramname"><span class="paramname"><em>nameid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee. </p>
<p>This case is for when we can't actually construct the shared pointer. Normally this would be caught as the pointer itself is serialized, but since this is a polymorphic pointer, if we tried to serialize the pointer we'd end up back here recursively. So we have to catch the error here as well, if this was a polymorphic type serialized by its proper pointer type </p>

</div>
</div>
<a id="a482cf9bb75c7d20d21e8ea9e887e2f67" name="a482cf9bb75c7d20d21e8ea9e887e2f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482cf9bb75c7d20d21e8ea9e887e2f67">&#9670;&#160;</a></span>serialize_wrapper() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T, class D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!traits::is_default_constructible&lt; T &gt;::value &amp;&amp;!traits::has_load_and_construct&lt; T, Archive &gt;::value)||std::is_abstract&lt; T &gt;::value, bool &gt;::type cereal::polymorphic_detail::serialize_wrapper </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t const</td>          <td class="paramname"><span class="paramname"><em>nameid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee. </p>
<p>This case is for when we can't actually construct the unique pointer. Normally this would be caught as the pointer itself is serialized, but since this is a polymorphic pointer, if we tried to serialize the pointer we'd end up back here recursively. So we have to catch the error here as well, if this was a polymorphic type serialized by its proper pointer type </p>

</div>
</div>
<a id="a6fa1b152a43117a484c4a11f382cc07a" name="a6fa1b152a43117a484c4a11f382cc07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa1b152a43117a484c4a11f382cc07a">&#9670;&#160;</a></span>serialize_wrapper() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(traits::is_default_constructible&lt; T &gt;::value||traits::has_load_and_construct&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract&lt; T &gt;::value, bool &gt;::type cereal::polymorphic_detail::serialize_wrapper </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t const</td>          <td class="paramname"><span class="paramname"><em>nameid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee. </p>
<p>This check lets us try and skip doing polymorphic machinery if we can get away with using the derived class serialize function</p>
<p>Note that on MSVC 2013 preview, is_default_constructible&lt;T&gt; returns true for abstract classes with default constructors, but on clang/gcc this will return false. So we also need to check for that here. </p>

</div>
</div>
<a id="a7af7795b2bcb38d405583464d6089deb" name="a7af7795b2bcb38d405583464d6089deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af7795b2bcb38d405583464d6089deb">&#9670;&#160;</a></span>serialize_wrapper() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive, class T, class D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(traits::is_default_constructible&lt; T &gt;::value||traits::has_load_and_construct&lt; T, Archive &gt;::value)&amp;&amp;!std::is_abstract&lt; T &gt;::value, bool &gt;::type cereal::polymorphic_detail::serialize_wrapper </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t const</td>          <td class="paramname"><span class="paramname"><em>nameid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee. </p>
<p>This check lets us try and skip doing polymorphic machinery if we can get away with using the derived class serialize function </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="../../dir_de7fce1d6d79f97cfe108c1ccf023fbc.html">cereal</a></li><li class="navelem"><a href="../../dir_861a362028be465a85fd819f2cae2eb0.html">types</a></li><li class="navelem"><a href="../../db/d23/polymorphic_8hpp.html">polymorphic.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
